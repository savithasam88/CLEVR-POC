# Copyright 2017-present, Facebook, Inc.
# All rights reserved.
#
# This source code is licensed under the BSD-style license found in the
# LICENSE file in the root directory of this source tree. An additional grant
# of patent rights can be found in the PATENTS file in the same directory.

from __future__ import print_function
import argparse, json, os, itertools, random, shutil, sys
import time
import re
import copy


from pathlib import Path
path_root = Path(__file__).parents[1]
sys.path.append(str(path_root))

path_current = str(Path(__file__).parents[0])

main_root = str(Path(__file__).parents[2])
sys.path.append(os.path.join(main_root, 'nesy-baseline/ns-vqa-master/reason/executors'))
from aspsolver import solve
#import question

#from matplotlib.cbook import print_cycles

#import question_engine as qeng

from generate_dataset import parser


"""
Generate synthetic questions and answers for CLEVR images. Input is a single
JSON file containing ground-truth scene information for all images, and output
is a single JSON file containing all generated questions, answers, and programs.

Questions are generated by expanding templates. Each template contains a single
program template and one or more text templates, both with the same set of typed
slots; by convention <Z> = Size, <C> = Color, <M> = Material, <S> = Shape.

Program templates may contain special nodes that expand into multiple functions
during instantiation; for example a "filter" node in a program template will
expand into a combination of "filter_size", "filter_color", "filter_material",
and "filter_shape" nodes after instantiation, and a "filter_unique" node in a
template will expand into some combination of filtering nodes followed by a
"unique" node.

Templates are instantiated using depth-first search; we are looking for template
instantiations where (1) each "unique" node actually refers to a single object,
(2) constraints in the template are satisfied, and (3) the answer to the question
passes our rejection sampling heuristics.

To efficiently handle (1) and (2), we keep track of partial evaluations of the
program during each step of template expansion. This together with the use of
composite nodes in program templates (filter_unique, relate_filter_unique) allow
us to efficiently prune the search space and terminate early when we know that
(1) or (2) will be violated.
"""

"""

parser = argparse.ArgumentParser()

# Inputs
parser.add_argument('--input_scene_file', default='../output/complete/scenes/all_scenes.json',
    help="JSON file containing ground-truth scene information for all images " +
         "from render_images.py")
parser.add_argument('--metadata_file', default='metadata.json',
    help="JSON file containing metadata about functions")
parser.add_argument('--synonyms_json', default='synonyms.json',
    help="JSON file defining synonyms for parameter values")
#parser.add_argument('--template_dir', default='CLEVR_1.0_templates',
parser.add_argument('--template_dir', default='CLEVR_ABDUCTIVE_templates',
    help="Directory containing JSON templates for questions")

# Output
parser.add_argument('--output_questions_file',
    default='../output/CLEVR_questions.json',
    help="The output file to write containing generated questions")

# Control which and how many images to process
parser.add_argument('--scene_start_idx', default=0, type=int,
    help="The image at which to start generating questions; this allows " +
         "question generation to be split across many workers")
parser.add_argument('--num_scenes', default=0, type=int,
    help="The number of images for which to generate questions. Setting to 0 " +
         "generates questions for all scenes in the input file starting from " +
         "--scene_start_idx")

# Control the number of questions per image; we will attempt to generate
# templates_per_image * instances_per_template questions per image.
parser.add_argument('--templates_per_image', default=5, type=int,
    help="The number of different templates that should be instantiated " +
         "on each image")
parser.add_argument('--instances_per_template', default=1, type=int,
    help="The number of times each template should be instantiated on an image")

# Misc
parser.add_argument('--reset_counts_every', default=250, type=int,
    help="How often to reset template and answer counts. Higher values will " +
         "result in flatter distributions over templates and answers, but " +
         "will result in longer runtimes.")
parser.add_argument('--verbose', action='store_true',
    help="Print more verbose output")
parser.add_argument('--time_dfs', action='store_true',
    help="Time each depth-first search; must be given with --verbose")
parser.add_argument('--profile', action='store_true',
    help="If given then run inside cProfile")
# args = parser.parse_args()
"""

#----------------------------------------------------------------------------------------
domain = {}
domain['color'] = ['gray', 'red', 'blue', 'green', 'brown', 'purple', 'cyan', 'yellow']
domain['material'] = ['rubber', 'metal']
domain['shape'] = ['cube', 'cylinder', 'sphere', 'cone']
domain['size'] = ['large', 'small', 'medium']

def precompute_filter_options(scene_struct, metadata):
  # Keys are tuples (size, color, shape, material) (where some may be None)
  # and values are lists of object idxs that match the filter criterion
  attribute_map = {}

  if metadata['dataset'] == 'CLEVR-v1.0':
    attr_keys = ['size', 'color', 'material', 'shape']
  else:
    assert False, 'Unrecognized dataset'

  # Precompute masks
  masks = []
  for i in range(2 ** len(attr_keys)):
    mask = []
    for j in range(len(attr_keys)):
      mask.append((i // (2 ** j)) % 2)
    masks.append(mask)

  for object_idx, obj in enumerate(scene_struct['objects']):
    if metadata['dataset'] == 'CLEVR-v1.0':
      keys = [tuple(obj[k] for k in attr_keys)]

    for mask in masks:
      for key in keys:
        masked_key = []
        for a, b in zip(key, mask):
          if b == 1:
            masked_key.append(a)
          else:
            masked_key.append(None)
        masked_key = tuple(masked_key)
        if masked_key not in attribute_map:
          attribute_map[masked_key] = set()
        attribute_map[masked_key].add(object_idx)

  scene_struct['_filter_options'] = attribute_map

#----------------------------------------------------------------------------------------

def find_filter_options(object_idxs, scene_struct, metadata):
  # Keys are tuples (size, color, shape, material) (where some may be None)
  # and values are lists of object idxs that match the filter criterion

  if '_filter_options' not in scene_struct:
    precompute_filter_options(scene_struct, metadata)

  attribute_map = {}
  object_idxs = set(object_idxs)
  for k, vs in scene_struct['_filter_options'].items():
    attribute_map[k] = sorted(list(object_idxs & vs))
  return attribute_map

#----------------------------------------------------------------------------------------

def add_empty_filter_options(attribute_map, metadata, num_to_add):
  # Add some filtering criterion that do NOT correspond to objects

  if metadata['dataset'] == 'CLEVR-v1.0':
    attr_keys = ['Size', 'Color', 'Material', 'Shape']
  else:
    assert False, 'Unrecognized dataset'
  
  attr_vals = [metadata['types'][t] + [None] for t in attr_keys]
  if '_filter_options' in metadata:
    attr_vals = metadata['_filter_options']

  target_size = len(attribute_map) + num_to_add
  while len(attribute_map) < target_size:
    k = (random.choice(v) for v in attr_vals)
    if k not in attribute_map:
      attribute_map[k] = []

#----------------------------------------------------------------------------------------

def find_relate_filter_options(object_idx, scene_struct, metadata,
    unique=False, include_zero=False, trivial_frac=0.1):
  options = {}
  if '_filter_options' not in scene_struct:
    precompute_filter_options(scene_struct, metadata)

  # TODO: Right now this is only looking for nontrivial combinations; in some
  # cases I may want to add trivial combinations, either where the intersection
  # is empty or where the intersection is equal to the filtering output.
  trivial_options = {}
  for relationship in scene_struct['relationships']:
    related = set(scene_struct['relationships'][relationship][object_idx])
    for filters, filtered in scene_struct['_filter_options'].items():
      intersection = related & filtered
      trivial = (intersection == filtered)
      if unique and len(intersection) != 1: continue
      if not include_zero and len(intersection) == 0: continue
      if trivial:
        trivial_options[(relationship, filters)] = sorted(list(intersection))
      else:
        options[(relationship, filters)] = sorted(list(intersection))

  N, f = len(options), trivial_frac
  num_trivial = int(round(N * f / (1 - f)))
  trivial_options = list(trivial_options.items())
  random.shuffle(trivial_options)
  for k, v in trivial_options[:num_trivial]:
    options[k] = v

  return options

#----------------------------------------------------------------------------------------

def node_shallow_copy(node):
  new_node = {
    'type': node['type'],
    'inputs': node['inputs'],
  }
  if 'side_inputs' in node:
    new_node['side_inputs'] = node['side_inputs']
  return new_node

#----------------------------------------------------------------------------------------

def other_heuristic(text, param_vals):
  """
  Post-processing heuristic to handle the word "other"
  """
  if ' other ' not in text and ' another ' not in text:
    return text
  target_keys = {
    '<Z>',  '<C>',  '<M>',  '<S>',
    '<Z2>', '<C2>', '<M2>', '<S2>',
  }
  if param_vals.keys() != target_keys:
    return text
  key_pairs = [
    ('<Z>', '<Z2>'),
    ('<C>', '<C2>'),
    ('<M>', '<M2>'),
    ('<S>', '<S2>'),
  ]
  remove_other = False
  for k1, k2 in key_pairs:
    v1 = param_vals.get(k1, None)
    v2 = param_vals.get(k2, None)
    if v1 != '' and v2 != '' and v1 != v2:
      print('other has got to go! %s = %s but %s = %s'
            % (k1, v1, k2, v2))
      remove_other = True
      break
  if remove_other:
    if ' other ' in text:
      text = text.replace(' other ', ' ')
    if ' another ' in text:
      text = text.replace(' another ', ' a ')
  text = re.sub(' +', ' ', text)
  return text



#-----------------------------------------------------------------------------------------------
#def Input_ASPEngine(preds, scene_struct, given_attribute, obj_rm):
#    program = ""
#    for pred in preds:
#        if pred.split("(")[1][0] == str(obj_rm):
#            for g in given_attribute:
#                if g in pred:
#                    program = program+"\n"+pred+"."
#                    break
#        else:    
#            program = program+"\n"+pred+"."
#    return program
#------------------------------------------------------------------------------------------------------
#def addRelations(incomplete_asp, scene_struct):
#    rel_preds = ""
#    
#    relations = scene_struct['relationships']
#    for rel in relations:
#        list_rel = relations[rel]
#        obj_no = 0
#        for obj in list_rel:
#            for other in obj:
#                rel_preds = rel_preds+rel+"("+other+","+obj_no+")."
#            obj_no = obj_no+1
#    incomplete_asp = incomplete_asp+rel_preds
#    return rel_preds
#--------------------------------------------------------------------------------------
def has_numbers(inputString):
    return bool(re.search(r'\d', inputString))
#------------------------------------------------------------------------------------
#vals dictionary -maps param name to its instantiated value
#fillVals - fills the value for params of type props_other of specific object 'other', id_other refers 
#to the id in the param name - eg "2" in <S2>   
def fillVals(param_name_to_type, vals, id_other, other, props_other, objects):
    if id_other=="":
        for p in props_other:
            for param in param_name_to_type:
                if param_name_to_type[param] == p and not(has_numbers(param))  : 
                    vals[param] = objects[other][p]
    else:    
        for p in props_other:
            for param in param_name_to_type:
                if param_name_to_type[param] == p and id_other in param  : 
                    vals[param] = objects[other][p]
    return vals
#----------------------------------------------------------------------------------
def getOtherProps(props, n1):
    props_other = []
    updated_props = copy.deepcopy(props)
    for i in range(n1):
          p = random.choice(updated_props)
          props_other.append(p)
          updated_props.remove(p)
          
    return props_other
#------------------------------------------------------------------------------------
#Find an object 'other' that is not obj_interest such that obj_R is in the 'R' of other  
def chooseRelation(relations, rels, obj_R, taboo):
      other = -1
      updated_relations = copy.deepcopy(relations)
      while(other == -1):
          R = random.choice(updated_relations)
          other = getObjs_Relation(rels, R, obj_R, taboo)
          if other == -1:
              updated_relations.remove(R)
          else:
              return R, other

def getObjs_Relation(rels, R, obj_R, taboo):

      list_list = rels[R]
      other_no = 0
      possible_other = []
      for l in list_list:
          if obj_R in l:
              if other_no not in taboo:
                  possible_other.append(other_no)
          other_no = other_no+1
      if len(possible_other)==0:
          return -1
      other = random.choice(possible_other) 
      return other
##---------------------------------------------------------------------------------------------
#def checkAmbiguity(incomplete_asp):
#        asp_file = open("incomplete.lp", "w")
#        n1 = asp_file.write(incomplete_asp)
#        asp_file.close()
#        asp_command = 'clingo 1'  + ' ' + os.path.join("incomplete.lp")
#        output_stream = os.popen(asp_command)
#        output = output_stream.read()
#        answers = output.split('Answer:')
#        #print("Answers:", answers)
#        answers = answers[1:]
#        count = 0
#        for answer in answers:
#            count = count+1
#            if(count>=1):
#                return False
#                
#        return True
##---------------------------------------------------------------------------------------------

#Find objects with value for the property 'relate_prop' similar to obj_interest's value for the same prop
def findSimilarObjects(scene_struct, relate_prop, obj_interest):
    similar = scene_struct["similar"]
    similar_objects = similar[relate_prop][obj_interest]
    return similar_objects
#---------------------------------------------------------------------------------------------
#def addSimilar(incomplete_asp):
#    same_rules = ""
#    same_rules = same_rules + "same_size(O1, O2):- hasProperty(O1, size, V1), hasProperty(O2, size, V1), O1!=O2. \n"
#    same_rules = same_rules + "same_color(O1, O2):- hasProperty(O1, color, V1), hasProperty(O2, color, V1), O1!=O2.\n"
#    same_rules = same_rules +"same_material(O1, O2):- hasProperty(O1, material, V1), hasProperty(O2, material, V1), O1!=O2. \n"
#    same_rules = same_rules +"same_shape(O1, O2):- hasProperty(O1, shape, V1), hasProperty(O2, shape, V1), O1!=O2. \n"
#    incomplete_asp = incomplete_asp + same_rules
#    return incomplete_asp
#-----------------------------------------------------------------------------------------------
#Get program for single_and questions
def getProgram_single_and(vals, param_name_to_type, program, rels, query_attribute):
    input_prev = 0
    for v in vals:
        node_f = {} 
        if "2" not in v  and "3" not in v and param_name_to_type[v] != "relation":
            node_f['type'] = "filter_"+param_name_to_type[v]
            node_f['side_inputs'] = [vals[v]]
            node_f['inputs'] = [input_prev]
            program['nodes'].append(node_f)
            input_prev = input_prev+1
    node_r = {}
    node_r["type"] = "relate_"+rels[-1]
    node_r["inputs"] = [input_prev]
    program['nodes'].append(node_r)
    input_prev = input_prev+1
    inter_1 = input_prev
    
    count = 0
    for v in vals:
        node_f = {} 
        if "2" in v and param_name_to_type[v] != "relation":
            node_f['type'] = "filter_"+param_name_to_type[v]
            node_f['side_inputs'] = [vals[v]]
            if count == 0:
                node_f['inputs'] = [0]
            else:
                node_f['inputs'] = [input_prev]
            program['nodes'].append(node_f)
            input_prev = input_prev+1
    node_r = {}
    node_r["type"] = "relate_"+rels[0]
    node_r["inputs"] = [input_prev]
    program['nodes'].append(node_r)
    input_prev = input_prev+1
    inter_2 = input_prev
    
    node_inter = {}
    node_inter["type"] = "inter"
    node_inter["inputs"] = [inter_1, inter_2]
    program['nodes'].append(node_inter)
    input_prev = input_prev+1
    
    node_query = {}
    node_query['type'] = "query_"+query_attribute
    node_query['inputs'] = [input_prev]
    program["nodes"].append(node_query)
    return program
    
#-----------------------------------------------------------------------------------------------
#Get program for same_relate questions
def getProgram_sim(vals, param_name_to_type, program, relate_prop, query_attribute):
    input_prev = 0
    for v in vals:
        node_f = {} 
        if "2" not in v and param_name_to_type[v] != "relation":
            node_f['type'] = "filter_"+param_name_to_type[v]
            node_f['side_inputs'] = [vals[v]]
            node_f['inputs'] = [input_prev]
            program['nodes'].append(node_f)
            input_prev = input_prev+1
    node_r = {}
    node_r["type"] = "same_"+relate_prop
    node_r["inputs"] = [input_prev]
    program['nodes'].append(node_r)
    input_prev = input_prev+1
    
    for v in vals:
        node_f = {} 
        if "2" in v and param_name_to_type[v] != "relation":
            node_f['type'] = "filter_"+param_name_to_type[v]
            node_f['side_inputs'] = [vals[v]]
            node_f['inputs'] = [input_prev]
            program['nodes'].append(node_f)
            input_prev = input_prev+1
    node_query = {}
    node_query['type'] = "query_"+query_attribute
    node_query['inputs'] = [input_prev]
    program["nodes"].append(node_query)
    return program
#--------------------------------------------------------------------------------------------------
#Get program for one_hop, two_hop and three_hop questions
def getProgram_rel(vals, param_name_to_type, program, hop, rels, query_attribute):
    input_prev = 0
    for v in vals:
        node_f = {} 
        if "2" not in v and "3" not in v and "4" not in v and param_name_to_type[v] != "relation" :
            node_f['type'] = "filter_"+param_name_to_type[v]
            node_f['side_inputs'] = [vals[v]]
            node_f['inputs'] = [input_prev]
            program['nodes'].append(node_f)
            input_prev = input_prev+1
    node_r = {}
    node_r["type"] = "relate_"+rels[-1]
    node_r["inputs"] = [input_prev]
    program['nodes'].append(node_r)
    input_prev = input_prev+1
    
    r = 1
    for i in range(2, hop+2):
        for v in vals:
            node_f = {} 
            if str(i) in v and param_name_to_type[v] != "relation":
                node_f['type'] = "filter_"+param_name_to_type[v]
                node_f['side_inputs'] = [vals[v]]
                node_f['inputs'] = [input_prev]
                program['nodes'].append(node_f)
                input_prev = input_prev+1
        if (hop-r)-1 < 0:
            continue
        node_r = {}
        node_r["type"] = "relate_"+rels[(hop-r)-1]
        node_r["inputs"] = [input_prev]
        program['nodes'].append(node_r)
        input_prev = input_prev+1
        r = r+1
    
    
    node_query = {}
    node_query['type'] = "query_"+query_attribute
    node_query['inputs'] = [input_prev]
    program["nodes"].append(node_query)
    return program
                
    
    
#---------------------------------------------------------------------------------------------------
def instantiate_templates_dfs(args, scene_struct, query_attribute, given_attribute, obj_interest,  template, template_type, template_id,  metadata, answer_counts, synonyms, max_instances=None, verbose=False):

  
  #print("Scene_struct:", scene_struct)
  #print("Template:", template)
  #print("metadata:", metadata)
  #print("Answer_counts:", answer_counts)
  #print("Synonyms:", synonyms)
  
  objects = scene_struct["objects"]
  param_name_to_type = {p['name']: p['type'].lower() for p in template['params']} 
  
  vals = {}
  
  #incomplete_asp = Input_ASPEngine(preds, scene_struct, given_attribute, obj_interest)
  
  relations = ['left', 'right', 'behind', 'front']
  props =  ['shape', 'color', 'size', 'material']
  query = ""
  program = {"nodes": [{'type': 'scene', 'inputs': []}]}
  #print("--query_attribute:",query_attribute, "--given:", given_attribute, "--obj_interest:", obj_interest)
  if "zero_hop" in template_type:
      
      input_prev = 0
      for g in given_attribute:
          node_g = {}
          #print("Given::", g, "param_name_to_type:", param_name_to_type)
          for param in param_name_to_type:
              if param_name_to_type[param] == g: 
                  vals[param] = objects[obj_interest][g]
                  node_g['type'] = "filter_"+g
                  node_g['side_inputs'] = [vals[param]]
                  node_g['inputs'] = [input_prev]
                  input_prev = input_prev+1
                  program["nodes"].append(node_g)
      
      pred_v = []
      
      for v in vals:
          
          pred_v.append("hasProperty(X,"+param_name_to_type[v]+","+vals[v]+")")
      
      query = "missing(Q):-hasProperty(X,"+query_attribute+", Q),"
      node_query = {}
      node_query['type'] = "query_"+query_attribute
      node_query['inputs'] = [input_prev]
      program["nodes"].append(node_query)
      for i in range(len(pred_v)):
          if i == len(pred_v)-1:
              query = query + pred_v[i]+"."
          else:
              query = query + pred_v[i]+","
      
     #!!! (query_attribute, vals), 
          
  elif "one_hop" in template_type:
      #incomplete_asp = addRelations(incomplete_asp, scene_struct)
      
      for g in given_attribute:
          for param in param_name_to_type:
              if param_name_to_type[param] == g and "2" in param: 
                  vals[param] = objects[obj_interest][g]
      #print("vals after filling given:", vals)
      rels = scene_struct["relationships"]
      
      R, other = chooseRelation(relations, rels, obj_interest, [obj_interest])
      
              
      #allowed_props_other = copy.deepcopy(props)
          
      n1 = random.randint(1, 4)
      props_other = getOtherProps(props, n1)
      vals = fillVals(param_name_to_type, vals, "", other, props_other, objects)
      
      for param in param_name_to_type:
          if param_name_to_type[param] == "relation":
              vals[param] = R
      query = ""
      pred_v = []
      for v in vals:
          if param_name_to_type[v]!="relation":
              if "2" in v : 
                  pred_v.append("hasProperty(X,"+param_name_to_type[v]+","+vals[v]+")")
              else:
                  pred_v.append("hasProperty(Y,"+param_name_to_type[v]+","+vals[v]+")")
      
      rel_pred = R+"(Y,X), X!=Y."
      query = "missing(Q):- hasProperty(X,"+query_attribute+",Q),"
      for i in range(len(pred_v)):
          query = query + pred_v[i]+","
      query = query+ rel_pred
      program = getProgram_rel(vals, param_name_to_type, program, 1, [R], query_attribute)
      
  
  elif  "two_hop" in template_type:
      rels = scene_struct["relationships"]
      R2, other2 = chooseRelation(relations, rels, obj_interest, [obj_interest])
      R, other =  chooseRelation(relations, rels, other2, [obj_interest, other2])
      for param in param_name_to_type:
          if param_name_to_type[param] == "relation" and "2" in param: 
              vals[param] = R2
          elif param_name_to_type[param] == "relation" and "2" not in param: 
              vals[param] = R
         
      
      for g in given_attribute:
          for param in param_name_to_type:
              if param_name_to_type[param] == g and "3" in param: 
                  vals[param] = objects[obj_interest][g]
      
      #What is query attribute of given that is R2 of other2 props that is R of other props
      
          
      n1 = random.randint(1, 4)
      n2 = random.randint(1, 4)
      props_other2 = getOtherProps(props, n1)
      props_other = getOtherProps(props, n2)
      vals = fillVals(param_name_to_type, vals, "2", other2, props_other2, objects)
      vals = fillVals(param_name_to_type, vals, "", other, props_other, objects)
      
      
      query = ""
      pred_v = []
      for v in vals:
          if param_name_to_type[v]!="relation":
              if "3" in v:
                  pred_v.append("hasProperty(X"+","+param_name_to_type[v]+","+vals[v]+")")
              elif "2" in v: 
                  pred_v.append("hasProperty(Y1,"+param_name_to_type[v]+","+vals[v]+")")
              else:
                  pred_v.append("hasProperty(Y2,"+param_name_to_type[v]+","+vals[v]+")")
      
      rel_pred1 = R2+"(Y1, X),"
      rel_pred2 = R+"(Y2, Y1), X!=Y1, Y1!=Y2, X!=Y2."
      query = "missing(Q):-hasProperty(X,"+query_attribute+",Q),"
      for i in range(len(pred_v)):
          query = query + pred_v[i]+","
      query = query+ rel_pred1+rel_pred2
      program = getProgram_rel(vals, param_name_to_type, program, 2, [R2, R], query_attribute)
      
  elif "three_hop" in template_type:
      #incomplete_asp = addRelations(incomplete_asp, scene_struct)
      rels = scene_struct["relationships"]
      R3, other3 = chooseRelation(relations, rels, obj_interest, [obj_interest])
      R2, other2 = chooseRelation(relations, rels, other3, [obj_interest, other3])
      R, other =  chooseRelation(relations, rels, other2, [obj_interest, other2, other3])
      for param in param_name_to_type:
          if param_name_to_type[param] == "relation" and "2" in param: 
              vals[param] = R2
          elif param_name_to_type[param] == "relation" and "3" in param: 
              vals[param] = R3
          elif param_name_to_type[param] == "relation" and "2" not in param and "3" not in param: 
              vals[param] = R
              
      for g in given_attribute:
          for param in param_name_to_type:
              if param_name_to_type[param] == g and "4" in param: 
                  vals[param] = objects[obj_interest][g]
      
      #What is query attribute of given that is R2 of other2 props that is R of other props
      
      n1 = random.randint(1, 4)
      n2 = random.randint(1, 4)
      n3 = random.randint(1, 4)
      props_other3 = getOtherProps(props, n1)
      props_other2 = getOtherProps(props, n2)
      props_other = getOtherProps(props, n3)
      vals = fillVals(param_name_to_type, vals, "3", other3, props_other3, objects)
      vals = fillVals(param_name_to_type, vals, "2", other2, props_other2, objects)
      vals = fillVals(param_name_to_type, vals, "", other, props_other, objects)
      
      
      query = ""
      pred_v = []
      for v in vals:
          if param_name_to_type[v]!="relation":
              if "4" in v:
                  pred_v.append("hasProperty(X,"+param_name_to_type[v]+","+vals[v]+")")
              elif "3" in v: 
                  pred_v.append("hasProperty(Y1,"+param_name_to_type[v]+","+vals[v]+")")
              elif "2" in v:
                  pred_v.append("hasProperty(Y2,"+param_name_to_type[v]+","+vals[v]+")")
              else :
                  pred_v.append("hasProperty(Y3,"+param_name_to_type[v]+","+vals[v]+")")

      rel_pred1 = R3+"(Y1,X),"
      rel_pred2 = R2+"(Y2, Y1),"
      rel_pred3 = R+"(Y3, Y2), X!=Y1, Y1!=Y2, Y2!=Y3, X!=Y2, X!=Y3, Y1!=Y3."
      
      query = "missing(Q):-hasProperty(X,"+query_attribute+",Q),"
      for i in range(len(pred_v)):
          query = query + pred_v[i]+","
      query = query+ rel_pred1+rel_pred2+rel_pred3
      program = getProgram_rel(vals, param_name_to_type, program, 3, [R3, R2, R], query_attribute)
      
  elif "same_relate" in template_type:
      #incomplete_asp = addSimilar(incomplete_asp)
      relate_prop = ""
      if template_id == 0 or template_id == 1:
          relate_prop = "size"
      elif template_id == 2 or template_id == 3 or template_id == 4:
          relate_prop = "color"
      elif template_id == 5 or template_id == 6 or template_id == 7:
          relate_prop = "material"
      elif template_id == 8 or template_id == 9 or template_id == 10:
          relate_prop = "shape"
      
      #print("Relate_prop:", relate_prop)

      for g in given_attribute:
          for param in param_name_to_type:
              if param_name_to_type[param] == g and "2" in param: 
                  vals[param] = objects[obj_interest][g]
                  
      sim_objects = findSimilarObjects(scene_struct, relate_prop, obj_interest)
      other = random.choice(sim_objects)
      n1 = random.randint(1, 2)
      allowedProps = []
      for p in props :
          if p != relate_prop:
              allowedProps.append(p)
              
      props_other = getOtherProps(allowedProps, n1)
      vals = fillVals(param_name_to_type, vals, "", other, props_other, objects)
      query = ""
      pred_v = []
      for v in vals:
          if param_name_to_type[v]!="relation":
              if "2" in v: 
                  pred_v.append("hasProperty(X,"+param_name_to_type[v]+","+vals[v]+")")
              else:
                  pred_v.append("hasProperty(Y,"+param_name_to_type[v]+","+vals[v]+")")
      
      rel_pred = "same_"+relate_prop+"(Y,X)."
      query = "missing(Q):-hasProperty(X,"+query_attribute+",Q), X!=Y, "
      for i in range(len(pred_v)):
          query = query + pred_v[i]+","
      query = query+ rel_pred
      program = getProgram_sim(vals, param_name_to_type, program, relate_prop, query_attribute)
      
  elif "single_and" in template_type:
      rels = scene_struct["relationships"]
      
      R2, other2 = chooseRelation(relations, rels, obj_interest, [obj_interest])
      R, other =  chooseRelation(relations, rels, obj_interest, [obj_interest, other2])
      
      
      for param in param_name_to_type:
          if param_name_to_type[param] == "relation" and "2" in param: 
              vals[param] = R2
          elif param_name_to_type[param] == "relation" and "2" not in param: 
              vals[param] = R
      
      for g in given_attribute:
          for param in param_name_to_type:
              if param_name_to_type[param] == g and "3" in param: 
                  vals[param] = objects[obj_interest][g]
      
      #What is query attribute of given that is R2 of other2 props and R of other props
      
      n1 = random.randint(1, 4)
      n2 = random.randint(1, 4)
      props_other2 = getOtherProps(props, n1)
      props_other = getOtherProps(props, n2)
      vals = fillVals(param_name_to_type, vals, "2", other2, props_other2, objects)
      vals = fillVals(param_name_to_type, vals, "", other, props_other, objects)
      
      
      query = ""
      pred_v = []
      for v in vals:
          if param_name_to_type[v]!="relation":
              if "3" in v:
                  pred_v.append("hasProperty(X"+","+param_name_to_type[v]+","+vals[v]+")")
              elif "2" in v: 
                  pred_v.append("hasProperty(Y1,"+param_name_to_type[v]+","+vals[v]+")")
              else:
                  pred_v.append("hasProperty(Y2,"+param_name_to_type[v]+","+vals[v]+")")
      
      rel_pred1 = R2+"(Y1, X),"
      rel_pred2 = R+"(Y2, X), X!=Y1, Y1!=Y2, X!=Y2."
      query = "missing(Q):-hasProperty(X,"+query_attribute+",Q),"
      for i in range(len(pred_v)):
          query = query + pred_v[i]+","
      query = query+ rel_pred1+rel_pred2
      
      program = getProgram_single_and(vals, param_name_to_type, program, [R2, R], query_attribute)
      
      
  
  text = random.choice(template['text'])
  for name, val in vals.items():
      if val in synonyms:
          val = random.choice(synonyms[val])
      
      text = text.replace(name, val)
      text = ' '.join(text.split())
  text = replace_optionals(text)
  text = ' '.join(text.split())
  pattern = re.compile("<S*[0-9]*>")
  syn_thing = random.choice(synonyms['thing'])
  text = pattern.sub(syn_thing,text)  
  pattern = re.compile("<.*?>")
  text = pattern.sub('',text)
  text_question = other_heuristic(text, vals)
  text_question = re.sub(' +', ' ', text_question)
  #print("Text_question:", text_question)   
  return text_question, program, query
      
  
#----------------------------------------------------------------------------------------

def replace_optionals(s):
  """
  Each substring of s that is surrounded in square brackets is treated as
  optional and is removed. For example the string

  "A [aa] B [bb]"

  would become any of

  "A  B "

  
  """
  pat = re.compile(r'\[([^\[]*)\]')

  while True:
    match = re.search(pat, s)
    if not match:
      break
    i0 = match.start()
    i1 = match.end()
    if random.random() > 0.5:
      s = s[:i0] + match.groups()[0] + s[i1:]
    else:
      s = s[:i0] + s[i1:]
  return s



#----------------------------------------------------------------------------------------
#Given an answer (prop_value), find the property to which it belongs to
def findQueryAttribute(prop_value):
    domain = {}
    domain['color'] = ['gray', 'red', 'blue', 'green', 'brown', 'purple', 'cyan', 'yellow'] #'green', 'purple', 'red', 'yellow', 'coral']
    domain['material'] = ['rubber', 'metal']
    domain['shape'] = ['cube', 'cylinder', 'sphere', 'cone']
    domain['size'] = ['large', 'small', 'medium']
    for key in domain:
        if prop_value in domain[key]:
            return key
    return None
#----------------------------------------------------------------------------------------
#to check whether the template in same_relate is allowed for the query_attribute, obj_interest and given_attribute
def checkAllowed(prop, given_attribute, query_attribute, obj_interest, complete_scene_struct):
     not_allowed = False
     if prop==query_attribute:
         not_allowed = True
     for g in given_attribute:
         if g == prop:
             not_allowed = True
     sim_objects = findSimilarObjects(complete_scene_struct, prop, obj_interest)
     if len(sim_objects) == 0:
         not_allowed = True
     return not_allowed
#-----------------------------------------------------------------------------------------
def get_allowed_templates(templates_items, num_questions_per_template_type, max_number_of_questions_per_template, template_answer_counts, given_attribute, query_attribute, obj_interest, complete_scene_struct):
    allowed_counter = {}
    
    for (fn, idx), template in templates_items:
        not_allowed = False
        answer_counts = template_answer_counts[(fn, idx)]
        prop = ""
        for key in answer_counts:
            prop = findQueryAttribute(key)
            break
        if (prop!=query_attribute):
            not_allowed = True
            continue
          
        if "same_relate" in fn:
          
            if idx == 0 or idx == 1:
                not_allowed = checkAllowed("size", given_attribute, query_attribute, obj_interest, complete_scene_struct)
            elif idx == 2 or idx == 3 or idx == 4:
                not_allowed = checkAllowed("color", given_attribute, query_attribute, obj_interest, complete_scene_struct)
            elif idx == 5 or idx == 6 or idx == 7:
                not_allowed = checkAllowed("material", given_attribute, query_attribute, obj_interest, complete_scene_struct)
            elif idx == 8 or idx == 9 or idx == 10:
                not_allowed = checkAllowed("shape", given_attribute, query_attribute, obj_interest, complete_scene_struct)
            if not_allowed:
                continue
        
        if len(given_attribute) == 0 and "zero_hop" in fn:
            not_allowed = True    
            continue        
          
        if not(not_allowed):
            allowed_counter[(fn,idx)] = num_questions_per_template_type[(fn, idx)]
    return allowed_counter
    
      

#-----------------------------------------------------------------------------------------
def generate_question(args,templates, num_loaded_templates, query_attribute, given_attribute, obj_interest, complete_scene_struct, complete_scene_path, scene_count, num_questions_per_template_type, max_number_of_questions_per_template, constraint_type_index, scene_folder, env_folder):
  
  with open(os.path.join(path_current, args.metadata_file), 'r') as f:
    metadata = json.load(f)
    dataset = metadata['dataset']
    if dataset != 'CLEVR-v1.0':
      raise ValueError('Unrecognized dataset "%s"' % dataset)
  
  functions_by_name = {}
  for f in metadata['functions']:
    functions_by_name[f['name']] = f
  metadata['_functions_by_name'] = functions_by_name

  # Load templates from disk
  # Key is (filename, file_idx)
#  num_loaded_templates = 0
#  
#  templates = {}
#  for fn in os.listdir(os.path.join(path_current, args.template_dir)):
#    
#    if not fn.endswith('.json'): continue
#    with open(os.path.join(path_current, args.template_dir, fn), 'r') as f:
#      #base = os.path.splitext(fn)[0]
#      for i, template in enumerate(json.load(f)):
#        num_loaded_templates += 1
#        key = (fn, i)
#        templates[key] = template
#  print('Read %d templates from disk' % num_loaded_templates)

  def reset_counts():
    # Maps a template (filename, index) to the number of questions we have
    # so far using that template
    template_counts = {}
    # Maps a template (filename, index) to a dict mapping the answer to the
    # number of questions so far of that template type with that answer
    template_answer_counts = {}
    node_type_to_dtype = {n['name']: n['output'] for n in metadata['functions']}
    
    for key, template in templates.items():
      template_counts[key[:2]] = 0
      final_node_type = template['nodes'][-1]['type']
      final_dtype = node_type_to_dtype[final_node_type]
      answers = metadata['types'][final_dtype]
      if final_dtype == 'Bool':
        answers = [True, False]
      if final_dtype == 'Integer':
        if metadata['dataset'] == 'CLEVR-v1.0':
          answers = list(range(0, 11))
      template_answer_counts[key[:2]] = {}
      for a in answers:
        template_answer_counts[key[:2]][a] = 0
    return template_counts, template_answer_counts

  template_counts, template_answer_counts = reset_counts()



  # Read file containing input scenes
  all_scenes = []
  with open(complete_scene_path, 'r') as f:
    scene_data = json.load(f)
    
    all_scenes = [scene_data]
    

  # Read synonyms file
  with open(os.path.join(path_current, args.synonyms_json), 'r') as f:
    synonyms = json.load(f)
    
  for i, scene in enumerate(all_scenes):
    scene_fn = scene['image_filename']
    scene_info = scene['info']
    print('starting image %s (%d / %d)'
          % (scene_fn, i + 1, len(all_scenes)))

    if scene_count % args.reset_counts_every == 0:
      print('resetting counts')
      template_counts, template_answer_counts = reset_counts()
    
    # Order templates by the number of questions we have so far for those
    # templates. This is a simple heuristic to give a flat distribution over
    # templates.
    templates_items = list(templates.items())
    templates_items = sorted(templates_items,
                        key=lambda x: template_counts[x[0][:2]])
    
        
    allowed_counter = get_allowed_templates(templates_items, num_questions_per_template_type, max_number_of_questions_per_template, template_answer_counts, given_attribute, query_attribute, obj_interest, complete_scene_struct)
    (fn, idx) = min(allowed_counter, key=allowed_counter.get) 
    template = templates[(fn, idx)]         
    num_questions_per_template_type[(fn, idx)] = num_questions_per_template_type[(fn, idx)] +1        
    if args.verbose:
        print('trying template ', fn, idx)
    if args.time_dfs and args.verbose:
        tic = time.time()
    ts, qs, asp_query = instantiate_templates_dfs(
                      args,
                      complete_scene_struct,
                      query_attribute, 
                      given_attribute, 
                      obj_interest, 
                      template,
                      fn,
                      idx,
                      metadata,
                      template_answer_counts[(fn, idx)],
                      synonyms,
                      max_instances=args.instances_per_template,
                      verbose=False)

    
    image_index = int(os.path.splitext(scene_fn)[0].split('_')[-1])
    possible_sols = solve(asp_query, image_index, constraint_type_index, '', scene_folder, env_folder)
    #input(possible_sols)
    if len(possible_sols) == 0:
        return None, False
    if len(possible_sols) == len(domain[query_attribute]):
         return None, False
    if args.time_dfs and args.verbose:
        toc = time.time()
        print('that took ', toc - tic)
    
    question = {
          'split': scene_info['split'],
          'image_filename': scene_fn,
          'image_index': image_index,
          'image': os.path.splitext(scene_fn)[0],
          'question': ts,
          'program': qs,
          'asp_query': asp_query,
          'answer': possible_sols,
          'object_interest': obj_interest,
          'template_filename': fn,
          'question_family_index': idx,
          'question_index': image_index
              }
    return question, True



#      if len(ts) > 0:
#        if args.verbose:
#          print('got one!')
#        num_instantiated += 1
#        template_counts[(fn, idx)] += 1
#      elif args.verbose:
#        print('did not get any =(')
#      if num_instantiated >= args.templates_per_image:
#        break

  # Change "side_inputs" to "value_inputs" in all functions of all functional
  # programs. My original name for these was "side_inputs" but I decided to
  # change the name to "value_inputs" for the public CLEVR release. I should
  # probably go through all question generation code and templates and rename,
  # but that could be tricky and take a while, so instead I'll just do it here.
  # To further complicate things, originally functions without value inputs did
  # not have a "side_inputs" field at all, and I'm pretty sure this fact is used
  # in some of the code above; however in the public CLEVR release all functions
  # have a "value_inputs" field, and it's an empty list for functions that take
  # no value inputs. Again this should probably be refactored, but the quick and
  # dirty solution is to keep the code above as-is, but here make "value_inputs"
  # an empty list for those functions that do not have "side_inputs". Gross.
#  for q in questions:
#    for f in q['program']:
#      if 'side_inputs' in f:
#        f['value_inputs'] = f['side_inputs']
#        del f['side_inputs']
#      else:
#        f['value_inputs'] = []
#
#  question_dir = os.path.join(args.incomplete_data_dir, args.question_dir)
#  if not os.path.isdir(question_dir):
#    os.makedirs(question_dir)
#
#  questions_file = os.path.join(question_dir, args.split + '.json')
#
#
#  with open(questions_file, 'w') as f:
#    print('Writing output to %s' % questions_file)
#    json.dump({
#        'info': scene_info,
#        'questions': questions,
#      }, f)

#----------------------------------------------------------------------------------------

#if __name__ == '__main__':
#  args = parser.parse_args()
#  if args.profile:
#    import cProfile
#    cProfile.run('main(args)')
#  else:
#    main(args)
#
